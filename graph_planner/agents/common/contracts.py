"""Prompt/response contracts shared by planner and CGM agents.

The project wires multiple agents together (planner LLM, CGM patch
generator, rule-based fallbacks).  To keep their expectations consistent we
define reusable prompt templates and response schemas here and let the
callers import these constants instead of re-stating the instructions in
multiple places.
"""

from __future__ import annotations

from dataclasses import dataclass
from textwrap import dedent
from typing import Dict, List


@dataclass(frozen=True)
class PromptContract:
    """Describe the high level agreement for an agent prompt.

    Attributes
    ----------
    name:
        Human readable name for logging / documentation.
    user_sections:
        Ordered list of sections that appear in the user prompt.  Each section
        is written as ``("section title", "brief description")`` and rendered
        in documentation so that dataset builders can keep the format stable.
    system_instructions:
        Detailed instructions that are injected as the system prompt.  This is
        written in English so the same text can be sent to models as-is.
    response_schema:
        Minimal JSON schema describing the keys that must appear in the
        response.  We use this schema to document the contract between the
        planner model and downstream code that parses the responses.
    """

    name: str
    user_sections: List[tuple[str, str]]
    system_instructions: str
    response_schema: Dict[str, str]

    def formatted_user_template(self) -> str:
        """Render the section titles as they appear in the prompt."""

        sections = []
        for title, description in self.user_sections:
            sections.append(f"[{title}] — {description}")
        return "\n".join(sections)

    def formatted_response_schema(self) -> str:
        """Render response schema for documentation."""

        lines = ["{" ]
        for key, description in self.response_schema.items():
            lines.append(f"  \"{key}\": {description}")
        lines.append("}")
        return "\n".join(lines)


PLANNER_CONTRACT = PromptContract(
    name="Planner agent contract",
    user_sections=[
        ("Issue", "Repository issue metadata (id, title, body)."),
        ("Instruction", "Latest environment observation and reward summary."),
        (
            "Planner memory",
            "Optional recap of subgraph expansions, snippets or repair state.",
        ),
    ],
    system_instructions=dedent(
        """
        You are the Graph Planner decision model.
        Every reply MUST contain exactly one text-trajectory block:

        <function=ACTION_NAME>
          <param name="thought"><![CDATA[free-form reasoning]]></param>
          <param name="k">JSON or text values</param>
        </function>

        Replace ACTION_NAME with one of: explore, memory, repair, submit, noop.
        Do not emit any other text outside the block.

        For each action:
        - explore: params may include op (find|expand|read), anchors (list),
          nodes (list), hop (int), limit (int).
        - memory: provide target (explore|observation), scope (turn|session),
          intent (commit|delete) and optional selector ("latest" or specific id).
        - repair: set subplan (multi-line steps, wrap in CDATA), optional
          focus_ids (list of graph node ids) and apply (true/false).
        - submit: no extra params besides thought.
        - noop: empty operation when no action fits.

        Encode lists/dicts as JSON. Use CDATA for multi-line text.
        """
    ).strip(),
    response_schema={
        "thought": "CDATA string inside <param name=\"thought\">.",
        "function": "ACTION_NAME in <function=...> (explore/memory/repair/submit/noop).",
        "params": dedent(
            """
            Additional <param> blocks. Keys depend on the action type and must
            encode JSON-compatible values (numbers, strings, lists, dicts).
            """
        ).strip(),
    },
)


CGM_CONTRACT = PromptContract(
    name="CGM patch contract",
    user_sections=[
        ("Issue", "Problem statement (title, body, stack traces)."),
        ("Instruction", "Planner request explaining the desired fix."),
        ("Plan", "Structured plan text generated by the planner agent."),
        ("Subgraph", "Linearised graph nodes relevant to the issue."),
        ("Snippets", "Candidate code spans selected for editing."),
    ],
    system_instructions=dedent(
        """
        You are CodeFuse-CGM, a graph-aware assistant that generates precise
        code patches.  Use the issue description, planner plan, graph context
        and snippets to derive the necessary edits.  Reply with a JSON object
        containing a top-level "patch" field.  The patch must include an
        "edits" array listing objects with "path", "start", "end" and
        "new_text" fields.  Ensure new_text entries end with a newline.
        """
    ).strip(),
    response_schema={
        "patch": dedent(
            """
            object — must contain an "edits" array with patch operations.
            Each edit requires "path" (string), "start" (int), "end" (int)
            and "new_text" (string ending with a newline).
            """
        ).strip(),
        "summary": "string — optional natural language description.",
    },
)


# Concrete instructions reused by agents
PLANNER_SYSTEM_PROMPT = PLANNER_CONTRACT.system_instructions
CGM_SYSTEM_PROMPT = CGM_CONTRACT.system_instructions

# Fallback/local runtime instructions focus on the response schema.
CGM_PATCH_INSTRUCTION = (
    "Generate a JSON object with a `patch` field. The `patch.edits` array must "
    "list objects containing `path`, `start`, `end`, and `new_text`. Ensure "
    "`new_text` ends with a newline."
)


__all__ = [
    "PromptContract",
    "PLANNER_CONTRACT",
    "CGM_CONTRACT",
    "PLANNER_SYSTEM_PROMPT",
    "CGM_SYSTEM_PROMPT",
    "CGM_PATCH_INSTRUCTION",
]

