"""Prompt/response contracts shared by planner and CGM agents.

The project wires multiple agents together (planner LLM, CGM patch
generator, rule-based fallbacks).  To keep their expectations consistent we
define reusable prompt templates and response schemas here and let the
callers import these constants instead of re-stating the instructions in
multiple places.
"""

from __future__ import annotations

from dataclasses import dataclass
from textwrap import dedent
from typing import Dict, List


@dataclass(frozen=True)
class PromptContract:
    """Describe the high level agreement for an agent prompt.

    Attributes
    ----------
    name:
        Human readable name for logging / documentation.
    user_sections:
        Ordered list of sections that appear in the user prompt.  Each section
        is written as ``("section title", "brief description")`` and rendered
        in documentation so that dataset builders can keep the format stable.
    system_instructions:
        Detailed instructions that are injected as the system prompt.  This is
        written in English so the same text can be sent to models as-is.
    response_schema:
        Minimal JSON schema describing the keys that must appear in the
        response.  We use this schema to document the contract between the
        planner model and downstream code that parses the responses.
    """

    name: str
    user_sections: List[tuple[str, str]]
    system_instructions: str
    response_schema: Dict[str, str]

    def formatted_user_template(self) -> str:
        """Render the section titles as they appear in the prompt."""

        sections = []
        for title, description in self.user_sections:
            sections.append(f"[{title}] — {description}")
        return "\n".join(sections)

    def formatted_response_schema(self) -> str:
        """Render response schema for documentation."""

        lines = ["{" ]
        for key, description in self.response_schema.items():
            lines.append(f"  \"{key}\": {description}")
        lines.append("}")
        return "\n".join(lines)


PLANNER_CONTRACT = PromptContract(
    name="Planner agent contract",
    user_sections=[
        ("Issue", "Repository issue metadata (id, title, body)."),
        ("Instruction", "Latest environment observation and reward summary."),
        (
            "Planner memory",
            "Optional recap of subgraph expansions, snippets or repair state.",
        ),
    ],
    system_instructions=dedent(
        """
        You are the Graph Planner decision model.
        Respond to every observation with a JSON object containing the keys
        "thought" and "action".  The "action" object must include a "type"
        field with one of: explore, memory, repair, submit.
        For explore actions you may also set "op" (find|expand|read),
        "anchors", "nodes", "hop", and "limit".  For memory actions provide
        "ops" describing memory operations.  For repair actions include
        "apply", "plan", "plan_targets", and optionally "patch".
        Always respond with valid JSON (optionally inside ```json fences).
        """
    ).strip(),
    response_schema={
        "thought": "string — natural language reasoning behind the action.",
        "action": dedent(
            """
            object — structured action payload with at least a "type" field.
            Additional fields depend on the action type: explore/memory/repair/
            submit.  Downstream code parses this payload to execute actions.
            """
        ).strip(),
    },
)


CGM_CONTRACT = PromptContract(
    name="CGM patch contract",
    user_sections=[
        ("Issue", "Problem statement (title, body, stack traces)."),
        ("Instruction", "Planner request explaining the desired fix."),
        ("Plan", "Structured plan text generated by the planner agent."),
        ("Subgraph", "Linearised graph nodes relevant to the issue."),
        ("Snippets", "Candidate code spans selected for editing."),
    ],
    system_instructions=dedent(
        """
        You are CodeFuse-CGM, a graph-aware assistant that generates precise
        code patches.  Use the issue description, planner plan, graph context
        and snippets to derive the necessary edits.  Reply with a JSON object
        containing a top-level "patch" field.  The patch must include an
        "edits" array listing objects with "path", "start", "end" and
        "new_text" fields.  Ensure new_text entries end with a newline.
        """
    ).strip(),
    response_schema={
        "patch": dedent(
            """
            object — must contain an "edits" array with patch operations.
            Each edit requires "path" (string), "start" (int), "end" (int)
            and "new_text" (string ending with a newline).
            """
        ).strip(),
        "summary": "string — optional natural language description.",
    },
)


# Concrete instructions reused by agents
PLANNER_SYSTEM_PROMPT = PLANNER_CONTRACT.system_instructions
CGM_SYSTEM_PROMPT = CGM_CONTRACT.system_instructions

# Fallback/local runtime instructions focus on the response schema.
CGM_PATCH_INSTRUCTION = (
    "Generate a JSON object with a `patch` field. The `patch.edits` array must "
    "list objects containing `path`, `start`, `end`, and `new_text`. Ensure "
    "`new_text` ends with a newline."
)


__all__ = [
    "PromptContract",
    "PLANNER_CONTRACT",
    "CGM_CONTRACT",
    "PLANNER_SYSTEM_PROMPT",
    "CGM_SYSTEM_PROMPT",
    "CGM_PATCH_INSTRUCTION",
]

